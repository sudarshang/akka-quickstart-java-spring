clustering {
  #For static use the below
  hostIP = "127.0.0.1"
  #For PCF use the below
  #hostIP = ${?CF_INSTANCE_INTERNAL_IP}
  #Port on which the akka remoting will start
  #Try to use the same port across multiple instances
  port = 9551
  #port = ${?AKKA_CLUSTERING_PORT}
  name = test-actor-system
  #Add or Update the seed hosts for the static instance(s) and update the cluster seed nodes accordingly
  #Try to deploy each node in a different box with same port
  seed-host = "127.0.0.1"
  #seed-host2= "192.10.68.256"
  seed-port = 9551
  seed-port2 = 9552
  #seed-port=3542
  #Use the below seed host for PCF instance
  #seed-host="vehicle-request-processor-dev.apps.internal"
  #seed-nodes will be constructed programmatically for PCF instances to join the cluster. For non cloud, list the seed nodes accordingly
  instances = 1
  management-port = 9558

}


akka {
  coordinated-shutdown.exit-jvm = off
  actor {
    provider = "cluster"
    # Timeout for ActorSystem.actorOf
    creation-timeout = 20s
    requestProcessor-dispatcher {
      # Dispatcher is the name of the event-based dispatcher
      type = Dispatcher
      # What kind of ExecutionService to use
      executor = "fork-join-executor"
      # Configuration for the fork join pool
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 2
        # Parallelism (threads) ... ceil(available processors * factor)
        parallelism-factor = 2.0
        # Max number of threads to cap factor-based parallelism number to
        parallelism-max = 10
      }
      # Throughput defines the maximum number of messages to be
      # processed per actor before the thread jumps to the next actor.
      # Set to 1 for as fair as possible.
      throughput = 1
    }
    serialize-messages = off
    serializers {
          jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
    }
    serialization-bindings {
      "com.example.JsonSerializable" = jackson-json
    }
  }
  remote {
    log-remote-lifecycle-events = off
    artery {
      # change this to enabled=on to use Artery instead of netty
      # see https://doc.akka.io/docs/akka/current/remoting-artery.html
      enabled = on
      transport = tcp
      canonical.hostname = ${clustering.hostIP}
      canonical.port = ${clustering.port}
    }

  }
  cluster {
  #Use this for static deployment. For Cloud, this is not needed, akka cluster bootstrap will create the cluster
    seed-nodes = ["akka://"${clustering.name}"@"${clustering.seed-host}":"${clustering.seed-port}]

    # Minimum required number of members before the leader changes member status
    # of 'Joining' members to 'Up'. Typically used together with
    # 'Cluster.registerOnMemberUp' to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = ${clustering.instances}
    # auto downing is NOT safe for production deployments.
    # you may want to use it during development, read more about it in the docs.
    #auto-down-unreachable-after = 10s
    #downing-provider-class = "com.gm.cei.caf.akka.cluster.sbr.dnsdowning.DnsDowningProvider"
    downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
    split-brain-resolver.active-strategy = "keep-oldest"
  }

  # Enable metrics extension in akka-cluster-metrics.
  akka.extensions=["akka.cluster.metrics.ClusterMetricsExtension"]

  # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
  # to STDOUT)
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  # Log level used by the configured loggers (see "loggers") as soon
  # as they have been started; before that, see "stdout-loglevel"
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = "DEBUG"

  # Log level for the very basic logger activated during ActorSystem startup.
  # This logger prints the log messages to stdout (System.out).
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  stdout-loglevel = "DEBUG"

  management {
      # registers bootstrap routes to be included in akka-management's http endpoint
      http {
          port = ${clustering.management-port}
      }
      http.routes {
        cluster-bootstrap = "akka.management.cluster.bootstrap.ClusterBootstrap$"
      }
      cluster.bootstrap {

          # Cluster Bootstrap will always attempt to join an existing cluster if possible. However
          # if no contact point advertises any seed-nodes a new cluster will be formed by the
          # node with the lowest address as decided by [[LowestAddressJoinDecider]].
          # Setting `new-cluster-enabled=off` after an initial cluster has formed is recommended to prevent new clusters
          # forming during a network partition when nodes are redeployed or restarted.
          # Replaces `form-new-cluster`, if `form-new-cluster` is set it takes precedence over this
          # property for backward compatibility
          new-cluster-enabled = on

          # Configuration for the first phase of bootstraping, during which contact points are discovered
          # using the configured service discovery mechanism (e.g. DNS records).
          contact-point-discovery {

            # Define this name to be looked up in service discovery for "neighboring" nodes
            # If undefined, the name will be taken from the AKKA_CLUSTER_BOOTSTRAP_SERVICE_NAME
            # environment variable or extracted from the ActorSystem name
            service-name = ${clustering.seed-host}


            # The portName passed to discovery. This should be set to the name of the port for Akka Management
            # If set to "" None is passed and ${akka.management.http.port} is assumed.
            port-name = ""

            # The protocol passed to discovery.
            # If set to "" None is passed.
            protocol = "akka-dns"

            # Added as suffix to the service-name to build the effective-service name used in the contact-point service lookups
            # If undefined, nothing will be appended to the service-name.
            #
            # Examples, set this to:
            # "default.svc.cluster.local" or "my-namespace.svc.cluster.local" for kubernetes clusters.
            service-namespace = "<service-namespace>"

            # The effective service name is the exact string that will be used to perform service discovery.
            #
            # Set this value to a specific string to override the default behaviour of building the effective name by
            # concatenating the `service-name` with the optional `service-namespace` (e.g. "name.default").
            effective-name = ${?AKKA_CLUSTER_BOOTSTRAP_SERVICE_NAME}

            # Config path of discovery method to be used to locate the initial contact points.
            # It must be a fully qualified config path to the discovery's config section.
            #
            # By setting this to `akka.discovery` we ride on the configuration mechanisms that akka-discovery has,
            # and reuse what is configured for it. You can set it explicitly to something else here, if you want to
            # use a different discovery mechanism for the bootstrap than for the rest of the application.
            discovery-method = akka.discovery

            # Amount of time for which a discovery observation must remain "stable"
            # (i.e. not change list of discovered contact-points) before a join decision can be made.
            # This is done to decrease the likelyhood of performing decisions on fluctuating observations.
            #
            # This timeout represents a tradeoff between safety and quickness of forming a new cluster.
            stable-margin = 5 seconds

            # Interval at which service discovery will be polled in search for new contact-points
            #
            # Note that actual timing of lookups will be the following:
            # - perform initial lookup; interval is this base interval
            # - await response within resolve-timeout
            #   (this can be larger than interval, which means interval effectively is resolveTimeout + interval,
            #    this has been specifically made so, to not hit discovery services with requests while the lookup is being serviced)
            #   - if failure happens apply backoff to interval (the backoff growth is exponential)
            # - if no failure happened, and we receive a resolved list of services, schedule another lookup in interval time
            #   - if previously failures happened during discovery, a successful lookup resets the interval to `interval` again
            # = repeat until stable-margin is reached
            interval = 1 second

            # Adds "noise" to vary the intervals between retries slightly (0.2 means 20% of base value).
            # This is important in order to avoid the various nodes performing lookups in the same interval,
            # potentially causing a thundering heard effect. Usually there is no need to tweak this parameter.
            exponential-backoff-random-factor = 0.2

            # Maximum interval to which the exponential backoff is allowed to grow
            exponential-backoff-max = 15 seconds

            # The smallest number of contact points that need to be discovered before the bootstrap process can start.
            # For optimal safety during cluster formation, you may want to set these value to the number of initial
            # nodes that you know will participate in the cluster (e.g. the value of `spec.replicas` as set in your kubernetes config.
            required-contact-point-nr = ${clustering.instances}

            # Timeout for getting a reply from the service-discovery subsystem
            resolve-timeout = 3 seconds
          }

          # Configured how we communicate with the contact point once it is discovered
          contact-point {

            # If no port is discovered along with the host/ip of a contact point this port will be used as fallback
            # Also, when no port-name is used and multiple results are returned for a given service, this port is
            # used to disambiguate. When set to <fallback-port>, defaults to the value of akka.management.http.port
            fallback-port = "<fallback-port>" # port pun, it "complements" 2552 which is often used for Akka remoting

            # If some discovered seed node will keep failing to connect for specified period of time,
            # it will initiate rediscovery again instead of keep trying.
            probing-failure-timeout = 3 seconds

            # Interval at which contact points should be polled
            # the effective interval used is this value plus the same value multiplied by the jitter value
            probe-interval = 1 second

            # Max amount of jitter to be added on retries
            probe-interval-jitter = 0.2
          }

          join-decider {
            # Implementation of JoinDecider.
            # It must extend akka.management.cluster.bootstrap.JoinDecider and
            # have public constructor with ActorSystem and ClusterBootstrapSettings
            # parameters.
            class = "akka.management.cluster.bootstrap.LowestAddressJoinDecider"
          }
      }

  }

}

